name: Minutely Turso Database Backup

on:
  schedule:
    # Run every minute
    - cron: "* * * * *"

  # Allow manual triggering for testing
  workflow_dispatch:

jobs:
  backup-database:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Use a token that can push to the repo
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create backup directory
        run: |
          mkdir -p database-backups

      - name: Get current timestamp
        id: timestamp
        run: |
          echo "timestamp=$(date -u '+%Y-%m-%d_%H-%M-%S')" >> $GITHUB_OUTPUT
          echo "iso_timestamp=$(date -u '+%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT

      - name: Validate API token and get organization info
        id: org_info
        run: |
          # First validate the API token
          echo "Validating API token..."
          VALIDATE_RESPONSE=$(curl -s -L 'https://api.turso.tech/v1/auth/validate' \
            -H 'Authorization: Bearer ${{ secrets.TURSO_API_TOKEN }}')

          echo "Validation response: $VALIDATE_RESPONSE"

          # Check if validation was successful
          if echo "$VALIDATE_RESPONSE" | grep -q '"error"'; then
            echo "❌ API Token validation failed!"
            echo "Response: $VALIDATE_RESPONSE"
            echo ""
            echo "🔧 To fix this issue:"
            echo "1. Create a new API token:"
            echo "   turso auth login"
            echo "   turso auth api-tokens create github-actions-backup"
            echo "2. Update the TURSO_API_TOKEN secret in your repository"
            echo "3. Make sure the token is copied exactly without extra spaces"
            exit 1
          fi

          echo "✅ API token is valid"

          # Get current user/organization info
          echo "Getting organization info..."
          ORG_RESPONSE=$(curl -s -L 'https://api.turso.tech/v1/current-user' \
            -H 'Authorization: Bearer ${{ secrets.TURSO_API_TOKEN }}')

          echo "User response: $ORG_RESPONSE"

          # Extract username - this will be the organization name for personal accounts
          ORG_NAME=$(echo "$ORG_RESPONSE" | grep -o '"username":"[^"]*"' | cut -d'"' -f4)

          if [ -z "$ORG_NAME" ]; then
            echo "❌ Failed to get organization name"
            echo "This might mean:"
            echo "1. You're using an expired token"
            echo "2. You're using the wrong type of token"
            echo "3. The token doesn't have the right permissions"
            echo ""
            echo "🔧 Try creating a new Platform API token:"
            echo "   turso auth login"
            echo "   turso auth api-tokens create github-actions-backup"
            exit 1
          fi

          echo "✅ Organization: $ORG_NAME"
          echo "org_name=$ORG_NAME" >> $GITHUB_OUTPUT

      - name: Create temporary backup database via API
        id: create_backup
        run: |
          # Create a temporary database from your main database at current point in time
          BACKUP_DB_NAME="backup-temp-${{ steps.timestamp.outputs.timestamp }}"
          echo "BACKUP_DB_NAME=$BACKUP_DB_NAME" >> $GITHUB_ENV

          # Create backup database using Platform API
          RESPONSE=$(curl -s -L -X POST \
            "https://api.turso.tech/v1/organizations/${{ steps.org_info.outputs.org_name }}/databases" \
            -H 'Authorization: Bearer ${{ secrets.TURSO_API_TOKEN }}' \
            -H 'Content-Type: application/json' \
            -d "{
              \"name\": \"$BACKUP_DB_NAME\",
              \"group\": \"default\",
              \"seed\": {
                \"type\": \"database\",
                \"name\": \"${{ vars.TURSO_DATABASE_NAME }}\",
                \"timestamp\": \"${{ steps.timestamp.outputs.iso_timestamp }}\"
              }
            }")

          echo "Create response: $RESPONSE"

          # Check if creation was successful
          HOSTNAME=$(echo "$RESPONSE" | grep -o '"Hostname":"[^"]*"' | cut -d'"' -f4)

          if [ -z "$HOSTNAME" ]; then
            echo "Failed to create backup database"
            echo "Response: $RESPONSE"
            exit 1
          fi

          echo "backup_hostname=$HOSTNAME" >> $GITHUB_OUTPUT
          echo "Created backup database: $BACKUP_DB_NAME at $HOSTNAME"

      - name: Wait for database to be ready
        run: |
          echo "Waiting 30 seconds for database to be ready..."
          sleep 30

      - name: Create database token for backup database
        id: db_token
        run: |
          # Create a database token for the backup database
          TOKEN_RESPONSE=$(curl -s -L -X POST \
            "https://api.turso.tech/v1/organizations/${{ steps.org_info.outputs.org_name }}/databases/$BACKUP_DB_NAME/auth/tokens" \
            -H 'Authorization: Bearer ${{ secrets.TURSO_API_TOKEN }}')

          echo "Token response: $TOKEN_RESPONSE"

          # Extract the token
          DB_TOKEN=$(echo "$TOKEN_RESPONSE" | grep -o '"jwt":"[^"]*"' | cut -d'"' -f4)

          if [ -z "$DB_TOKEN" ]; then
            echo "Failed to create database token"
            echo "Response: $TOKEN_RESPONSE"
            exit 1
          fi

          echo "db_token=$DB_TOKEN" >> $GITHUB_OUTPUT

      - name: Install libsql-client
        run: |
          # Install Node.js and libsql client to dump the database
          npm install -g @libsql/client

      - name: Create backup script
        run: |
          cat > backup_script.js << 'EOF'
          const { createClient } = require('@libsql/client');
          const fs = require('fs');

          async function createBackup() {
            const client = createClient({
              url: process.env.BACKUP_DB_URL,
              authToken: process.env.BACKUP_DB_TOKEN
            });
            
            try {
              // Get all table names
              const tables = await client.execute("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'");
              
              let sqlDump = "PRAGMA foreign_keys=OFF;\nBEGIN TRANSACTION;\n\n";
              
              for (const table of tables.rows) {
                const tableName = table.name;
                
                // Get table schema
                const schema = await client.execute(`SELECT sql FROM sqlite_master WHERE type='table' AND name='${tableName}'`);
                if (schema.rows.length > 0) {
                  sqlDump += schema.rows[0].sql + ";\n\n";
                }
                
                // Get table data
                const data = await client.execute(`SELECT * FROM ${tableName}`);
                
                if (data.rows.length > 0) {
                  for (const row of data.rows) {
                    const columns = Object.keys(row);
                    const values = columns.map(col => {
                      const val = row[col];
                      if (val === null) return 'NULL';
                      if (typeof val === 'string') return `'${val.replace(/'/g, "''")}'`;
                      return val;
                    });
                    
                    sqlDump += `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES (${values.join(', ')});\n`;
                  }
                  sqlDump += "\n";
                }
              }
              
              sqlDump += "COMMIT;\n";
              
              // Write SQL dump to file
              fs.writeFileSync(process.env.SQL_DUMP_FILE, sqlDump);
              console.log(`SQL dump created: ${process.env.SQL_DUMP_FILE}`);
              
            } catch (error) {
              console.error('Error creating backup:', error);
              process.exit(1);
            } finally {
              client.close();
            }
          }

          createBackup();
          EOF

      - name: Create SQL dump from backup database
        run: |
          # Set environment variables for the backup script
          export BACKUP_DB_URL="libsql://${{ steps.create_backup.outputs.backup_hostname }}"
          export BACKUP_DB_TOKEN="${{ steps.db_token.outputs.db_token }}"
          export SQL_DUMP_FILE="database-backups/backup_${{ steps.timestamp.outputs.timestamp }}.sql"

          echo "SQL_DUMP_FILE=$SQL_DUMP_FILE" >> $GITHUB_ENV

          # Run the backup script
          node backup_script.js

      - name: Compress backup file
        run: |
          # Compress the SQL dump to save space
          gzip "$SQL_DUMP_FILE"
          echo "Compressed backup created: ${SQL_DUMP_FILE}.gz"

      - name: Clean up temporary database
        run: |
          # Delete the temporary backup database to avoid cluttering your Turso account
          curl -s -L -X DELETE \
            "https://api.turso.tech/v1/organizations/${{ steps.org_info.outputs.org_name }}/databases/$BACKUP_DB_NAME" \
            -H 'Authorization: Bearer ${{ secrets.TURSO_API_TOKEN }}'

          echo "Temporary database $BACKUP_DB_NAME deleted"

      - name: Create backup metadata
        run: |
          # Create a metadata file with backup information
          cat > database-backups/backup_${{ steps.timestamp.outputs.timestamp }}_metadata.json << EOF
          {
            "timestamp": "${{ steps.timestamp.outputs.timestamp }}",
            "iso_timestamp": "${{ steps.timestamp.outputs.iso_timestamp }}",
            "source_database": "${{ vars.TURSO_DATABASE_NAME }}",
            "backup_files": [
              "backup_${{ steps.timestamp.outputs.timestamp }}.sql.gz"
            ],
            "created_by": "github-actions",
            "workflow_run": "${{ github.run_id }}",
            "organization": "${{ steps.org_info.outputs.org_name }}"
          }
          EOF

      - name: Clean up old backups (keep last 60 minutes)
        run: |
          # Remove backup files older than 60 minutes to prevent repository from growing too large
          find database-backups -name "backup_*.sql.gz" -mmin +60 -delete || true
          find database-backups -name "backup_*_metadata.json" -mmin +60 -delete || true

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Commit and push backup files
        run: |
          # Add all new backup files
          git add database-backups/

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No new backup files to commit"
            exit 0
          fi

          # Commit the backup files
          git commit -m "🗄️ Minutely database backup - ${{ steps.timestamp.outputs.timestamp }}"

          # Push to the repository
          git push

      - name: Create release with backup files (optional)
        if: github.event_name == 'schedule' && github.ref == 'refs/heads/main'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: backup-${{ steps.timestamp.outputs.timestamp }}
          release_name: Database Backup ${{ steps.timestamp.outputs.timestamp }}
          body: |
            Automated minutely backup of Turso database

            **Backup Details:**
            - Timestamp: ${{ steps.timestamp.outputs.timestamp }}
            - Source Database: ${{ vars.TURSO_DATABASE_NAME }}
            - Organization: ${{ steps.org_info.outputs.org_name }}
            - Files: SQL dump (gzipped)

            **Files in this backup:**
            - `backup_${{ steps.timestamp.outputs.timestamp }}.sql.gz` - SQL dump file
            - `backup_${{ steps.timestamp.outputs.timestamp }}_metadata.json` - Backup metadata
          draft: false
          prerelease: false
