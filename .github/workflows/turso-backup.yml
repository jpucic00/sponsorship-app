name: Minutely Turso Database Backup

on:
  schedule:
    # Run every minute
    - cron: "* * * * *"

  # Allow manual triggering for testing
  workflow_dispatch:

jobs:
  backup-database:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          # Use a token that can push to the repo
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create backup directory
        run: |
          mkdir -p database-backups

      - name: Get current timestamp
        id: timestamp
        run: |
          echo "timestamp=$(date -u '+%Y-%m-%d_%H-%M-%S')" >> $GITHUB_OUTPUT
          echo "iso_timestamp=$(date -u '+%Y-%m-%dT%H:%M:%SZ')" >> $GITHUB_OUTPUT

      - name: Validate API token and get organization info
        id: org_info
        run: |
          # First validate the API token
          echo "Validating API token..."
          VALIDATE_RESPONSE=$(curl -s -L 'https://api.turso.tech/v1/auth/validate' \
            -H 'Authorization: Bearer ${{ secrets.TURSO_API_TOKEN }}')

          echo "Validation response: $VALIDATE_RESPONSE"

          # Check if validation was successful
          if echo "$VALIDATE_RESPONSE" | grep -q '"error"'; then
            echo "âŒ API Token validation failed!"
            echo "Response: $VALIDATE_RESPONSE"
            echo ""
            echo "ğŸ”§ To fix this issue:"
            echo "1. Create a new API token:"
            echo "   turso auth login"
            echo "   turso auth api-tokens create github-actions-backup"
            echo "2. Update the TURSO_API_TOKEN secret in your repository"
            echo "3. Make sure the token is copied exactly without extra spaces"
            exit 1
          fi

          echo "âœ… API token is valid"

          # Get current user/organization info
          echo "Getting organization info..."
          ORG_RESPONSE=$(curl -s -L 'https://api.turso.tech/v1/current-user' \
            -H 'Authorization: Bearer ${{ secrets.TURSO_API_TOKEN }}')

          echo "User response: $ORG_RESPONSE"

          # Extract username - this will be the organization name for personal accounts
          ORG_NAME=$(echo "$ORG_RESPONSE" | grep -o '"username":"[^"]*"' | cut -d'"' -f4)

          if [ -z "$ORG_NAME" ]; then
            echo "âŒ Failed to get organization name"
            echo "This might mean:"
            echo "1. You're using an expired token"
            echo "2. You're using the wrong type of token"
            echo "3. The token doesn't have the right permissions"
            echo ""
            echo "ğŸ”§ Try creating a new Platform API token:"
            echo "   turso auth login"
            echo "   turso auth api-tokens create github-actions-backup"
            exit 1
          fi

          echo "âœ… Organization: $ORG_NAME"
          echo "org_name=$ORG_NAME" >> $GITHUB_OUTPUT

      - name: Create temporary backup database via API
        id: create_backup
        run: |
          # Create a temporary database from your main database at current point in time
          BACKUP_DB_NAME="backup-temp-${{ steps.timestamp.outputs.timestamp }}"
          echo "BACKUP_DB_NAME=$BACKUP_DB_NAME" >> $GITHUB_ENV

          # Create backup database using Platform API
          RESPONSE=$(curl -s -L -X POST \
            "https://api.turso.tech/v1/organizations/${{ steps.org_info.outputs.org_name }}/databases" \
            -H 'Authorization: Bearer ${{ secrets.TURSO_API_TOKEN }}' \
            -H 'Content-Type: application/json' \
            -d "{
              \"name\": \"$BACKUP_DB_NAME\",
              \"group\": \"default\",
              \"seed\": {
                \"type\": \"database\",
                \"name\": \"${{ vars.TURSO_DATABASE_NAME }}\",
                \"timestamp\": \"${{ steps.timestamp.outputs.iso_timestamp }}\"
              }
            }")

          echo "Create response: $RESPONSE"

          # Check if creation was successful
          HOSTNAME=$(echo "$RESPONSE" | grep -o '"Hostname":"[^"]*"' | cut -d'"' -f4)

          if [ -z "$HOSTNAME" ]; then
            echo "Failed to create backup database"
            echo "Response: $RESPONSE"
            exit 1
          fi

          echo "backup_hostname=$HOSTNAME" >> $GITHUB_OUTPUT
          echo "Created backup database: $BACKUP_DB_NAME at $HOSTNAME"

      - name: Wait for database to be ready
        run: |
          echo "Waiting 30 seconds for database to be ready..."
          sleep 30

      - name: Create database token for backup database
        id: db_token
        run: |
          # Create a database token for the backup database
          TOKEN_RESPONSE=$(curl -s -L -X POST \
            "https://api.turso.tech/v1/organizations/${{ steps.org_info.outputs.org_name }}/databases/$BACKUP_DB_NAME/auth/tokens" \
            -H 'Authorization: Bearer ${{ secrets.TURSO_API_TOKEN }}')

          echo "Token response: $TOKEN_RESPONSE"

          # Extract the token
          DB_TOKEN=$(echo "$TOKEN_RESPONSE" | grep -o '"jwt":"[^"]*"' | cut -d'"' -f4)

          if [ -z "$DB_TOKEN" ]; then
            echo "Failed to create database token"
            echo "Response: $TOKEN_RESPONSE"
            exit 1
          fi

          echo "db_token=$DB_TOKEN" >> $GITHUB_OUTPUT

      - name: Install libsql-client
        run: |
          # Install Node.js and libsql client to dump the database
          npm install -g @libsql/client

      - name: Create backup script
        run: |
          cat > backup_script.js << 'EOF'
          const { createClient } = require('@libsql/client');
          const fs = require('fs');

          async function createBackup() {
            const client = createClient({
              url: process.env.BACKUP_DB_URL,
              authToken: process.env.BACKUP_DB_TOKEN
            });
            
            try {
              // Get all table names
              const tables = await client.execute("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%'");
              
              let sqlDump = "PRAGMA foreign_keys=OFF;\nBEGIN TRANSACTION;\n\n";
              
              for (const table of tables.rows) {
                const tableName = table.name;
                
                // Get table schema
                const schema = await client.execute(`SELECT sql FROM sqlite_master WHERE type='table' AND name='${tableName}'`);
                if (schema.rows.length > 0) {
                  sqlDump += schema.rows[0].sql + ";\n\n";
                }
                
                // Get table data
                const data = await client.execute(`SELECT * FROM ${tableName}`);
                
                if (data.rows.length > 0) {
                  for (const row of data.rows) {
                    const columns = Object.keys(row);
                    const values = columns.map(col => {
                      const val = row[col];
                      if (val === null) return 'NULL';
                      if (typeof val === 'string') return `'${val.replace(/'/g, "''")}'`;
                      return val;
                    });
                    
                    sqlDump += `INSERT INTO ${tableName} (${columns.join(', ')}) VALUES (${values.join(', ')});\n`;
                  }
                  sqlDump += "\n";
                }
              }
              
              sqlDump += "COMMIT;\n";
              
              // Write SQL dump to file
              fs.writeFileSync(process.env.SQL_DUMP_FILE, sqlDump);
              console.log(`SQL dump created: ${process.env.SQL_DUMP_FILE}`);
              
            } catch (error) {
              console.error('Error creating backup:', error);
              process.exit(1);
            } finally {
              client.close();
            }
          }

          createBackup();
          EOF

      - name: Create SQL dump from backup database
        run: |
          # Set environment variables for the backup script
          export BACKUP_DB_URL="libsql://${{ steps.create_backup.outputs.backup_hostname }}"
          export BACKUP_DB_TOKEN="${{ steps.db_token.outputs.db_token }}"
          export SQL_DUMP_FILE="database-backups/backup_${{ steps.timestamp.outputs.timestamp }}.sql"

          echo "SQL_DUMP_FILE=$SQL_DUMP_FILE" >> $GITHUB_ENV

          # Run the backup script
          node backup_script.js

      - name: Compress backup file
        run: |
          # Compress the SQL dump to save space
          gzip "$SQL_DUMP_FILE"
          echo "Compressed backup created: ${SQL_DUMP_FILE}.gz"

      - name: Clean up temporary database
        run: |
          # Delete the temporary backup database to avoid cluttering your Turso account
          curl -s -L -X DELETE \
            "https://api.turso.tech/v1/organizations/${{ steps.org_info.outputs.org_name }}/databases/$BACKUP_DB_NAME" \
            -H 'Authorization: Bearer ${{ secrets.TURSO_API_TOKEN }}'

          echo "Temporary database $BACKUP_DB_NAME deleted"

      - name: Create backup metadata
        run: |
          # Create a metadata file with backup information
          cat > database-backups/backup_${{ steps.timestamp.outputs.timestamp }}_metadata.json << EOF
          {
            "timestamp": "${{ steps.timestamp.outputs.timestamp }}",
            "iso_timestamp": "${{ steps.timestamp.outputs.iso_timestamp }}",
            "source_database": "${{ vars.TURSO_DATABASE_NAME }}",
            "backup_files": [
              "backup_${{ steps.timestamp.outputs.timestamp }}.sql.gz"
            ],
            "created_by": "github-actions",
            "workflow_run": "${{ github.run_id }}",
            "organization": "${{ steps.org_info.outputs.org_name }}"
          }
          EOF

      - name: Clean up old backups (keep last 60 minutes)
        run: |
          # Remove backup files older than 60 minutes to prevent repository from growing too large
          find database-backups -name "backup_*.sql.gz" -mmin +60 -delete || true
          find database-backups -name "backup_*_metadata.json" -mmin +60 -delete || true

      - name: Configure Git
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

      - name: Commit and push backup files
        run: |
          # Add all new backup files
          git add database-backups/

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No new backup files to commit"
            exit 0
          fi

          # Commit the backup files
          git commit -m "ğŸ—„ï¸ Minutely database backup - ${{ steps.timestamp.outputs.timestamp }}"

          # Push to the repository
          git push

      - name: Create release with backup files (optional)
        if: github.event_name == 'schedule' && github.ref == 'refs/heads/main'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: backup-${{ steps.timestamp.outputs.timestamp }}
          release_name: Database Backup ${{ steps.timestamp.outputs.timestamp }}
          body: |
            Automated minutely backup of Turso database

            **Backup Details:**
            - Timestamp: ${{ steps.timestamp.outputs.timestamp }}
            - Source Database: ${{ vars.TURSO_DATABASE_NAME }}
            - Organization: ${{ steps.org_info.outputs.org_name }}
            - Files: SQL dump (gzipped)

            **Files in this backup:**
            - `backup_${{ steps.timestamp.outputs.timestamp }}.sql.gz` - SQL dump file
            - `backup_${{ steps.timestamp.outputs.timestamp }}_metadata.json` - Backup metadata
          draft: false
          prerelease: false
